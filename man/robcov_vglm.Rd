% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/robcov_vglm.R
\name{robcov_vglm}
\alias{robcov_vglm}
\title{Robust (Sandwich) Covariance Matrix Estimation for vglm Objects}
\usage{
robcov_vglm(fit, cluster = NULL, adjust = FALSE)
}
\arguments{
\item{fit}{A fitted vglm object from the VGAM package.}

\item{cluster}{Optional vector of cluster identifiers. If provided, computes
cluster-robust standard errors. Must have the same length as the number of
observations.}

\item{adjust}{Logical. If TRUE, applies small-sample correction factor
G/(G-1) for clustered data, where G is the number of clusters. Default is
FALSE to match \code{rms::robcov()} behavior.}
}
\value{
A list with class "robcov_vglm" containing all original model
information plus robust covariance estimates:

\strong{Model information (copied from original vglm fit):}
\item{coefficients}{Model coefficients}
\item{fitted.values}{Fitted values from the model}
\item{residuals}{Model residuals}
\item{family}{The VGAM family object}
\item{predictors}{Linear predictors (eta)}
\item{prior.weights}{Prior weights}
\item{df.residual}{Residual degrees of freedom}
\item{df.total}{Total degrees of freedom}
\item{rank}{Model rank}
\item{criterion}{Convergence criterion values}
\item{constraints}{Constraint matrices}
\item{control}{Control parameters}
\item{extra}{Extra information from family}
\item{misc}{Miscellaneous model info}
\item{model}{Model frame (if available)}
\item{x}{Design matrix (if available)}
\item{y}{Response (if available)}
\item{terms}{Model terms}
\item{assign}{Assignment vector}
\item{xlevels}{Factor levels}
\item{na.action}{NA handling}
\item{call}{Original model call}
\item{original_call}{Call to robcov_vglm}

\strong{Robust covariance estimates:}
\item{var}{The robust variance-covariance matrix}
\item{se}{Robust standard errors (sqrt of diagonal)}
\item{z}{Z-statistics (coefficients / robust SE)}
\item{pvalues}{Two-sided p-values based on z-statistics}
\item{original_vcov}{The original model-based variance-covariance matrix}
\item{original_se}{Original model-based standard errors}

\strong{Sandwich components:}
\item{scores}{Matrix of observation-level score contributions (n x p)}
\item{bread}{The "bread" matrix (scaled inverse Hessian)}
\item{meat}{The "meat" matrix}

\strong{Clustering information:}
\item{cluster}{The cluster variable (if provided)}
\item{n}{Number of observations}
\item{n_clusters}{Number of clusters (if clustered)}
\item{adjust}{Whether small-sample adjustment was applied}
}
\description{
Computes the Huber-White sandwich covariance matrix estimator for vglm
objects, optionally with cluster-robust standard errors. This provides
functionality similar to \code{rms::robcov()} for vglm models.
}
\details{
The sandwich estimator has the form:
\deqn{V = B \cdot M \cdot B / n}
where B is the "bread" (n times the inverse of the negative Hessian, i.e.,
n * vcov(fit)) and M is the "meat" (the variance of the score contributions).

For unclustered data, the meat matrix is:
\deqn{M = \frac{1}{n} \sum_{i=1}^{n} \psi_i \psi_i'}
where \eqn{\psi_i} is the score (gradient of log-likelihood) for observation i.

For clustered data, scores are summed within clusters before computing the
meat matrix:
\deqn{M = \frac{1}{n} \sum_{g=1}^{G} \left(\sum_{i \in g} \psi_i\right)
      \left(\sum_{i \in g} \psi_i\right)'}

When \code{adjust = TRUE}, the meat matrix is multiplied by G/(G-1) for clustered
data, providing a small-sample bias correction. This is sometimes recommended
but is not applied by \code{rms::robcov()}, so the default is FALSE for
consistency.

\strong{Z-statistics and p-values}: The returned object includes z-statistics
computed as coefficients divided by robust standard errors, and two-sided
p-values from the standard normal distribution. These can be used for
inference that is robust to model misspecification or within-cluster
correlation.

\strong{Comparison with rms::robcov()}: This function produces nearly identical
results to \code{rms::robcov()} when used with equivalent models:
\itemize{
\item For binary outcomes (vglm with binomialff vs orm), results match to
numerical precision
\item For ordinal outcomes (vglm with cumulative vs orm), small differences
(~0.1-1.5\%) may occur due to different internal parameterizations, but
the results are practically equivalent
}
}
\examples{
\\dontrun{
library(VGAM)

# Fit a proportional odds model
fit <- vglm(y ~ x1 + x2,
            family = cumulative(parallel = TRUE, reverse = TRUE),
            data = mydata)

# Compute robust (unclustered) standard errors
robust_vcov <- robcov_vglm(fit)
robust_vcov$se

# Compute cluster-robust standard errors
robust_vcov_cl <- robcov_vglm(fit, cluster = mydata$cluster_id)
robust_vcov_cl$se

# With small-sample correction
robust_vcov_adj <- robcov_vglm(fit, cluster = mydata$cluster_id, adjust = TRUE)
}

}
\seealso{
\code{\link{compare_se_orm_vglm}} for comparing standard errors
between orm and vglm fits
}
