% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sops_new.R
\name{inferences}
\alias{inferences}
\title{Bootstrap Inference for State Occupation Probabilities}
\usage{
inferences(
  object,
  method = "bootstrap",
  n_boot = 1000,
  parallel = FALSE,
  workers = NULL,
  update_datadist = TRUE,
  conf_level = 0.95,
  return_bootstrap = FALSE,
  ...
)
}
\arguments{
\item{object}{A \code{markov_avg_sops} object from \code{avg_sops()}.}

\item{method}{Character. Currently only "bootstrap" is supported.}

\item{n_boot}{Number of bootstrap iterations.}

\item{parallel}{Logical. Use parallel processing?}

\item{workers}{Number of parallel workers. If NULL, uses detectCores() - 1.}

\item{update_datadist}{Logical. Whether to update datadist for rms models.}

\item{conf_level}{Confidence level for intervals (default 0.95).}

\item{return_bootstrap}{Logical. If TRUE, stores all individual bootstrap
estimates as an attribute that can be extracted with \code{draw_bootstrap()}.
This allows users to plot distributions, compute custom statistics, or
aggregate across time. Default is FALSE to save memory.}

\item{...}{Additional arguments (currently unused).}
}
\value{
The input object with added columns:
\item{conf.low}{Lower confidence bound}
\item{conf.high}{Upper confidence bound}
\item{std.error}{Bootstrap standard error}

If \code{return_bootstrap = TRUE}, the object also has a "bootstrap_draws"
attribute containing a data frame with all individual bootstrap estimates.
Extract with \code{get_draws()}.
}
\description{
Adds bootstrap confidence intervals to \code{avg_sops} objects. Implements the
same robust approach as \code{bootstrap_standardized_sops()} for handling rare
states in bootstrap samples.
}
\details{
This function implements group bootstrap resampling (by patient ID) with
proper handling of rare states that may be missing from bootstrap samples:

\strong{Bootstrap Procedure:}
\enumerate{
\item Sample patient IDs with replacement using \code{fast_group_bootstrap()}
\item For each bootstrap sample:
\itemize{
\item Relevel factors to consecutive integers if states are missing
\item Refit the model on the bootstrap data
\item Predict on the ORIGINAL counterfactual grid (not bootstrap sample)
\item Map predictions back to original state space
\item Zero-pad missing states (they have 0 probability in that bootstrap)
}
\item Compute quantile-based confidence intervals across bootstrap iterations
}

\strong{Missing State Handling:}
When a state is absent from a bootstrap sample:
\itemize{
\item The model is refit without that state level
\item The \code{pvarname} values in the prediction data are mapped to the new levels
\item Results are expanded back to the original state space
\item Missing states receive probability 0 (not NA)
}

This approach maintains valid probability distributions (sum to 1) and
avoids the need for imputation or jittering strategies.
}
\examples{
\dontrun{
# Compute marginal SOPs with bootstrap CIs
result <- avg_sops(
  model = fit,
  newdata = data,
  variables = list(tx = c(0, 1)),
  times = 1:60,
  ylevels = 1:6,
  absorb = 6,
  id_var = "id"
) |>
  inferences(n_boot = 500, parallel = TRUE, workers = 4)

# Extract individual bootstrap draws for custom analyses
result_with_draws <- avg_sops(...) |>
  inferences(n_boot = 500, return_bootstrap = TRUE)

# Get all bootstrap estimates
boot_draws <- draw_bootstrap(result_with_draws)

# Example: Compute mean time in state 1 for each bootstrap iteration
library(dplyr)
time_in_state <- boot_draws |>
  filter(state == 1, tx == 1) |>
  group_by(boot_id) |>
  summarise(mean_time = sum(estimate))
}

}
\seealso{
\code{\link[=avg_sops]{avg_sops()}}, \code{\link[=bootstrap_standardized_sops]{bootstrap_standardized_sops()}},
\code{\link[=fast_group_bootstrap]{fast_group_bootstrap()}}, \code{\link[=relevel_factors_consecutive]{relevel_factors_consecutive()}}

\code{\link[=get_draws]{get_draws()}} to extract all individual draws from any sampling procedure
}
