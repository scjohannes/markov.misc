% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/robcov_vglm.R
\name{compare_se_orm_vglm}
\alias{compare_se_orm_vglm}
\title{Compare Standard Errors from orm and vglm}
\usage{
compare_se_orm_vglm(orm_fit, vglm_fit, cluster = NULL)
}
\arguments{
\item{orm_fit}{A fitted orm object from the rms package.}

\item{vglm_fit}{A fitted vglm object from the VGAM package. Should be fit
with \code{cumulative(parallel = TRUE, reverse = TRUE)} to match orm's
parameterization for ordinal outcomes, or \code{binomialff} for binary outcomes.}

\item{cluster}{Optional cluster variable for robust standard errors. Must
have the same length as the number of observations in both models.}
}
\value{
A data frame comparing standard errors with columns:
\item{parameter}{Parameter name (intercepts numbered, then regression
coefficients)}
\item{se_orm_model}{Model-based SE from orm}
\item{se_vglm_model}{Model-based SE from vglm}
\item{se_orm_robust}{Robust SE from orm}
\item{se_vglm_robust}{Robust SE from vglm}
\item{ratio_model}{Ratio of vglm to orm model-based SEs}
\item{ratio_robust}{Ratio of vglm to orm robust SEs}
}
\description{
Utility function to compare standard errors between \code{rms::orm()} and
\code{VGAM::vglm()} fits, including robust (sandwich) versions. This is useful
for validating that both approaches give similar results.
}
\details{
This function aligns parameters between the two model types:
\itemize{
\item orm uses names like "y>=2", "y>=3", etc. for intercepts (or "Intercept"
for binary outcomes)
\item vglm uses names like "(Intercept):1", "(Intercept):2", etc.
}

The comparison focuses on:
\enumerate{
\item Model-based standard errors (from the inverse Hessian)
\item Robust (sandwich) standard errors
}

Ratios close to 1.0 indicate good agreement. Small differences (~1-2\%) are
expected for ordinal outcomes due to different internal implementations.
}
\examples{
\dontrun{
library(rms)
library(VGAM)

# Fit models
dd <- datadist(mydata)
options(datadist = "dd")
m_orm <- orm(y ~ x1 + x2, data = mydata, x = TRUE, y = TRUE)
m_vglm <- vglm(y ~ x1 + x2,
               family = cumulative(parallel = TRUE, reverse = TRUE),
               data = mydata)

# Compare standard errors
comparison <- compare_se_orm_vglm(m_orm, m_vglm)
print(comparison)

# With clustering
comparison_cl <- compare_se_orm_vglm(m_orm, m_vglm, cluster = mydata$id)
}

}
