% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootstrap_helpers.R
\name{apply_to_bootstrap}
\alias{apply_to_bootstrap}
\title{Apply Function to Bootstrap Samples with Parallelization}
\usage{
apply_to_bootstrap(
  boot_samples,
  analysis_fn,
  data,
  id_var,
  parallel = FALSE,
  workers = NULL,
  packages = c("rms", "VGAM", "Hmisc", "stats", "dplyr"),
  globals = character(0)
)
}
\arguments{
\item{boot_samples}{List of bootstrap ID lookups from
\code{\link{fast_group_bootstrap}}. Each element should be a data frame
with columns: original_id, new_id, boot_id.}

\item{analysis_fn}{Function to apply to each bootstrap sample. Should accept
a data frame and return a result (can be any type).}

\item{data}{The original data frame (before bootstrap sampling). This will
be joined with boot_samples on each worker to materialize the data.}

\item{id_var}{Name of the grouping variable in data (e.g., "id")}

\item{parallel}{Logical indicating whether to use parallel processing
(default FALSE)}

\item{workers}{Number of workers for parallel processing. If NULL (default),
uses parallel::detectCores() - 1}

\item{packages}{Character vector of packages needed by \code{analysis_fn}.
Default is c("rms", "VGAM", "Hmisc", "stats", "dplyr")}

\item{globals}{Character vector of global variables/functions needed by
\code{analysis_fn}. These will be exported to each worker.}
}
\value{
A list of length \code{length(boot_samples)} containing the results
from applying \code{analysis_fn} to each bootstrap sample.
}
\description{
Helper function to apply an analysis function to bootstrap samples with
optional parallel processing. Handles just-in-time materialization of
bootstrap data for memory efficiency.
}
\details{
This function implements a memory-efficient just-in-time bootstrap approach:
\enumerate{
\item Bootstrap ID lookups are distributed to workers (minimal memory)
\item Each worker receives a copy of the original data
\item Worker materializes bootstrap data by joining IDs with original data
\item Worker runs analysis and returns only the result
\item Full bootstrap datasets are never stored in memory simultaneously
}

If \code{parallel = TRUE}, uses future.callr::callr strategy for parallel
processing, which provides isolated R processes for each worker. This makes
it safe to modify the global environment (e.g., for datadist).

If \code{parallel = FALSE}, uses sequential processing with purrr::map().
}
\examples{
\dontrun{
# Define analysis function (receives full bootstrap data)
analyze_boot <- function(boot_data) {
  # Update datadist
  dd <- rms::datadist(boot_data)
  assign("dd", dd, envir = .GlobalEnv)
  options(datadist = "dd")

  # Refit model
  m <- update(original_model, data = boot_data)

  # Return coefficient
  coef(m)["tx"]
}

# Generate bootstrap IDs (not full data)
boot_ids <- fast_group_bootstrap(my_data, id_var = "id", n_boot = 2000)

# Apply to bootstrap samples with just-in-time materialization
results <- apply_to_bootstrap(
  boot_samples = boot_ids,
  analysis_fn = analyze_boot,
  data = my_data,
  id_var = "id",
  parallel = TRUE,
  globals = c("original_model")
)
}

}
