% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power.R
\name{run_power_iteration}
\alias{run_power_iteration}
\title{Run One Power Simulation Iteration}
\usage{
run_power_iteration(
  iter_num,
  data_paths,
  sample_size = 250,
  allocation_ratio = 0.5,
  seed = 123,
  fit_functions
)
}
\arguments{
\item{iter_num}{Integer. Iteration number for tracking.}

\item{data_paths}{Named list of paths to datasets. Must include "markov" and
optionally "t_test" and "drs". Example:
\code{list(markov = "ha_or_0.8.parquet", t_test = "t_data_or_0.8.parquet")}.}

\item{sample_size}{Integer. Total number of patients to sample (default: 250).}

\item{allocation_ratio}{Numeric. Proportion assigned to treatment (default: 0.5).}

\item{seed}{Integer. Base random seed (default: 123). Actual seed will be
\code{seed + iter_num}.}

\item{fit_functions}{Named list of functions that fit models and return tidy
results. Each function should accept \code{data} and \code{iter} arguments and return
a tibble with columns: \code{iter}, \code{analysis}, \code{term}, \code{estimate}, \code{std_error},
\code{p_value}, \code{conf_low}, \code{conf_high}.}
}
\value{
A tibble combining results from all analysis functions with columns:
\itemize{
\item iter: Iteration number
\item analysis: Analysis type
\item term: Coefficient name
\item estimate: Point estimate
\item std_error: Standard error
\item statistic: Test statistic
\item p_value: P-value
\item conf_low, conf_high: Confidence interval
}
}
\description{
Executes a complete simulation iteration: sampling patients, fitting models,
and extracting treatment effects across multiple analysis methods.
}
\details{
This function provides a flexible framework for power simulations by accepting
custom fitting functions. This allows complete control over model specification,
package choice, and fitting options.

Each fitting function should:
\enumerate{
\item Accept \code{data} (the sampled dataset) and \code{iter} (iteration number)
\item Fit the model
\item Return a tibble with results in standardized format
}
}
\examples{
\dontrun{
# Define custom fitting functions
fit_markov <- function(data, iter) {
  model_data <- prepare_markov_data(data)
  fit <- vglm(y ~ tx + rcs(time, 4) + yprev,
              family = cumulative(parallel = TRUE, reverse = TRUE),
              data = model_data)
  tidy_po(fit) |>
    filter(term == "tx") |>
    mutate(iter = iter, analysis = "markov", .before = 1)
}

fit_ttest <- function(data, iter) {
  res <- t.test(y ~ tx, data = data)
  tibble(
    iter = iter,
    analysis = "t_test",
    term = "tx",
    estimate = -diff(res$estimate),
    std_error = res$stderr,
    p_value = res$p.value,
    conf_low = -res$conf.int[2],
    conf_high = -res$conf.int[1]
  )
}

# Run iteration
result <- run_power_iteration(
  iter_num = 1,
  data_paths = list(
    markov = "sim_data/ha_or_0.8.parquet",
    t_test = "sim_data/t_data_or_0.8.parquet"
  ),
  sample_size = 200,
  fit_functions = list(markov = fit_markov, t_test = fit_ttest)
)
}

}
