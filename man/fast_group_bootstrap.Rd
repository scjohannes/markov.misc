% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootstrap_helpers.R
\name{fast_group_bootstrap}
\alias{fast_group_bootstrap}
\title{Fast Group Bootstrap ID Sampler}
\usage{
fast_group_bootstrap(data, id_var = "id", n_boot)
}
\arguments{
\item{data}{A data frame containing the patient data}

\item{id_var}{Character string specifying the name of the ID variable for
group bootstrap (default "id")}

\item{n_boot}{Number of bootstrap samples to generate}
}
\value{
A list of length \code{n_boot}, where each element is a data frame
(ID lookup table) with columns:
\itemize{
\item original_id: The sampled group ID from the original data
\item new_id: Unique identifier for resampled groups (e.g., "1_1", "1_2")
\item boot_id: Bootstrap iteration number
}
}
\description{
Generates bootstrap samples by resampling group IDs (e.g., patient IDs) with
replacement. Returns only the sampled IDs, not the full data, for memory
efficiency. This is much faster and more memory-efficient than
rsample::group_bootstraps() for datasets with many groups.
}
\details{
The ID lookup tables are later joined with the original data on-demand using
\code{\link{materialize_bootstrap_sample}}, so each parallel worker only
materializes the data it needs for analysis.

The new_id column ensures that if a group is sampled multiple times in
the same bootstrap iteration, each instance gets a unique identifier
(e.g., "1_1", "1_2"), which is necessary for refitting models that expect
unique group identifiers.

This approach is dramatically faster than rsample::group_bootstraps() for
datasets with many groups or unbalanced group sizes, because rsample uses
an inefficient "oversampling then trimming" strategy. See GitHub issue
tidymodels/rsample#357 for details.
}
\examples{
\dontrun{
# Generate 2000 bootstrap ID samples
boot_ids <- fast_group_bootstrap(my_data, id_var = "id", n_boot = 2000)

# Each element contains only the sampled IDs (very small)
boot_ids[[1]]

# To get a full bootstrap sample, materialize it:
boot_sample <- materialize_bootstrap_sample(boot_ids[[1]], my_data, "id")

# Use with parallel processing - data is materialized on each worker
library(furrr)
plan(callr)
results <- future_map(boot_ids, function(ids) {
  boot_data <- materialize_bootstrap_sample(ids, my_data, "id")
  analyze_bootstrap(boot_data)
})
}

}
