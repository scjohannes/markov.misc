% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power.R
\name{assess_operating_characteristics}
\alias{assess_operating_characteristics}
\alias{run_power_iteration}
\title{Assess Operating Characteristics for One Iteration}
\usage{
assess_operating_characteristics(
  iter_num,
  data_paths,
  sample_size = 250,
  allocation_ratio = 0.5,
  seed = 123,
  fit_functions,
  inference_type = c("coef", "state"),
  use_bootstrap = FALSE,
  n_bootstrap = NULL,
  id_var = "id",
  workers = NULL,
  ylevels = 1:6,
  absorb = 6,
  target_states = 1,
  varnames = list(tvarname = "time", pvarname = "yprev", id = "id", tx = "tx")
)

run_power_iteration(
  iter_num,
  data_paths,
  sample_size = 250,
  allocation_ratio = 0.5,
  seed = 123,
  fit_functions,
  inference_type = c("coef", "state"),
  use_bootstrap = FALSE,
  n_bootstrap = NULL,
  id_var = "id",
  workers = NULL,
  ylevels = 1:6,
  absorb = 6,
  target_states = 1,
  varnames = list(tvarname = "time", pvarname = "yprev", id = "id", tx = "tx")
)
}
\arguments{
\item{iter_num}{Integer. Iteration number for tracking.}

\item{data_paths}{Named list of paths to datasets. Must include "markov" and
optionally "t_test" and "drs". Example:
\code{list(markov = "ha_or_0.8.parquet", t_test = "t_data_or_0.8.parquet")}.}

\item{sample_size}{Integer. Total number of patients to sample (default: 250).}

\item{allocation_ratio}{Numeric. Proportion assigned to treatment (default: 0.5).}

\item{seed}{Integer. Base random seed (default: 123). Actual seed will be
\code{seed + iter_num}.}

\item{fit_functions}{Named list of functions that fit models and return tidy
results. Each function should accept \code{data} and \code{iter} arguments and return
a tibble with columns: \code{iter}, \code{analysis}, \code{term}, \code{estimate}, \code{std_error},
\code{p_value}, \code{conf_low}, \code{conf_high}.}

\item{inference_type}{Character. Type of inference: "coef" for coefficient-based
(default) or "state" for state-occupancy-based. State-based inference always
uses bootstrap and requires additional parameters (see below).}

\item{use_bootstrap}{Logical. Whether to use bootstrap for coefficient-based
inference (default: FALSE). Always TRUE for state-based inference.}

\item{n_bootstrap}{Integer. Number of bootstrap samples (required when
use_bootstrap = TRUE or inference_type = "state").}

\item{id_var}{Character. Name of the ID variable for group bootstrap (default: "id").}

\item{workers}{Integer. Number of parallel workers for bootstrap (default: NULL).
When NULL, bootstrap runs sequentially. Set to > 1 to parallelize bootstrap
within a single iteration (useful when running a single analysis, not when
parallelizing across iterations). \strong{Note}: Typically you parallelize across
calls to \code{assess_operating_characteristics()} rather than within each call.}

\item{ylevels}{Integer vector. State levels for state-based inference (default: 1:6).}

\item{absorb}{Integer. Absorbing state for state-based inference (default: 6).}

\item{target_states}{Integer vector. Target states for state-based inference (default: 1).}

\item{varnames}{List. Variable names for state-based inference (default:
list(tvarname = "time", pvarname = "yprev", id = "id", tx = "tx")).}
}
\value{
A tibble combining results from all analysis functions with columns:
\itemize{
\item iter: Iteration number
\item analysis: Analysis type
\item term: Coefficient name
\item estimate: Point estimate
\item std_error: Standard error
\item statistic: Test statistic
\item p_value: P-value
\item conf_low, conf_high: Confidence interval
}
}
\description{
Executes a complete simulation iteration: sampling patients, fitting models,
and extracting treatment effects across multiple analysis methods. This function
can be used to assess both power (when true effect â‰  0) and Type I error
(when true effect = 0).
}
\details{
This function provides a flexible framework for assessing operating characteristics
(power, Type I error, bias, coverage) by accepting custom fitting functions.
This allows complete control over model specification, package choice, and
fitting options.

Each fitting function should:
\enumerate{
\item Accept \code{data} (the sampled dataset) and \code{iter} (iteration number)
\item Fit the model
\item Return a tibble with results in standardized format
}

\strong{Inference types}:
\enumerate{
\item \strong{Coefficient-based} (inference_type = "coef", default):
\itemize{
\item Fits models using fit_functions and extracts coefficients
\item Can use bootstrap or naive SEs depending on use_bootstrap
\item Suitable for testing treatment effects via regression coefficients
}
\item \strong{State-based} (inference_type = "state"):
\itemize{
\item Calculates treatment effect as difference in time spent in target state(s)
\item Always uses bootstrap (required for CIs on state occupancy differences)
\item Requires a fitted model in fit_functions that returns a model object
\item Uses state occupancy probabilities via soprobMarkovOrdm (for orm) or similar
}
}

\strong{Bootstrap inference}: When \code{use_bootstrap = TRUE} or \code{inference_type = "state"},
the function performs group bootstrap resampling. This is particularly useful for:
\itemize{
\item vglm models (VGAM package) which don't support robust standard errors
\item State-based inference (only way to get CIs on state occupancy differences)
\item Accounting for within-patient correlation in coefficient estimates
}

\strong{Parallelization strategy}: The typical workflow is to parallelize across
simulation iterations, not within them:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Recommended: Parallelize across iterations
library(furrr)
plan(multisession, workers = 8)
results <- future_map_dfr(1:1000, ~assess_operating_characteristics(
  iter_num = ., ...
))
}\if{html}{\out{</div>}}

Only set \code{workers > 1} when running a single analysis with many bootstrap samples
and NOT parallelizing across iterations.
}
\examples{
\dontrun{
# Coefficient-based inference (default)
fit_markov <- function(data, iter) {
  model_data <- prepare_markov_data(data)
  fit <- vglm(y ~ tx + rcs(time, 4) + yprev,
              family = cumulative(parallel = TRUE, reverse = TRUE),
              data = model_data)
  tidy_po(fit) |>
    filter(term == "tx") |>
    mutate(iter = iter, analysis = "markov", .before = 1)
}

result_coef <- assess_operating_characteristics(
  iter_num = 1,
  data_paths = list(markov = "sim_data/ha_or_0.8.parquet"),
  sample_size = 200,
  fit_functions = list(markov = fit_markov),
  inference_type = "coef",
  use_bootstrap = TRUE,
  n_bootstrap = 500
)

# State-based inference (always uses bootstrap)
fit_markov_model <- function(data, iter) {
  model_data <- prepare_markov_data(data)
  d <- datadist(model_data)
  options(datadist = "d")
  orm(y ~ tx + rcs(time, 4) + yprev, data = model_data, x = TRUE, y = TRUE)
}

result_state <- assess_operating_characteristics(
  iter_num = 1,
  data_paths = list(markov = "sim_data/ha_or_0.8.parquet"),
  sample_size = 200,
  fit_functions = list(markov = fit_markov_model),
  inference_type = "state",
  n_bootstrap = 500,
  target_states = 1
)
}

}
