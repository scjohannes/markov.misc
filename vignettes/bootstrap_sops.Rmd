---
title: "Bootstrap Marginal State Occupation Probabilities"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Bootstrap Marginal State Occupation Probabilities}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Setup

```{r setup, message=FALSE, warning=FALSE}
library(markov.misc)
library(arrow)
library(dplyr)
library(tidyr)
library(furrr)
library(rms)
library(VGAM)
library(ggplot2)
library(patchwork)

N_PATIENTS <- 250
R <- 300
SEED <- 234567
FU <- 60

DATA_PATH <- file.path(tempdir(), "sim_data")
OUTPUT_PATH <- file.path(tempdir(), "sim_output")

# Create directories
if (!dir.exists(DATA_PATH)) dir.create(DATA_PATH)
if (!dir.exists(OUTPUT_PATH)) dir.create(OUTPUT_PATH)
```

## Step 1: Simualte Trial Data

```{r superpop}
markov_data <- sim_trajectories_brownian(
  n_patients = N_PATIENTS,
  follow_up_time = FU,
  treatment_prob = 0.5,
  absorbing_state = 6,
  seed = SEED,
  mu_treatment_effect = 0
)

# Plot state occupation probabilities (SOPs)
esop <- plot_sops(
  markov_data, 
  geom = "line", 
  facet_var = NULL, 
  linetype_var = "tx") + 
  scale_color_brewer(palette = "Dark2") +
  coord_cartesian(ylim = c(0, 1.0)) +
  theme(
    legend.position = ""
  )

esop

# Calculate True Effect: Difference in time in state 1 (Home)
es_calc <- calc_time_in_state_diff(markov_data, target_state = 1)
es <- es_calc$true_effect[1]
```

## Step 2: Fit Model

```{r}
data <- prepare_markov_data(markov_data)

time_spl_m <- rcs(data$time, 4)
knots <- attr(time_spl_m, "parms")

data$time_lin <- as.vector(time_spl_m[, 1])
data$time_nlin_1 <- as.vector(time_spl_m[, 2])
data$time_nlin_2 <- as.vector(time_spl_m[, 3])

t_covs <-  data |> 
  select(time_lin, time_nlin_1, time_nlin_2) |> 
  distinct() |> 
  arrange(time_lin) |> 
  data.frame()

M <- 5

cons_tx <- list(
  # Intercept need identift matrix
  "(Intercept)"     = diag(M),

  # Proportional odds terms need column of ones
  "rcs(time, 4)"              = cbind(PO_effect = 1),
  "yprev"                     = cbind(PO_effect = 1),

  # Linear constraint for baseline effect
  "tx" = cbind(
    tx_1_4 = c(1, 1, 1, 1, 0),
    tx_5    = c(0, 0, 0, 0, 1)
  )
)

cons_time <- list(
  # Intercept need identity matrix
  "(Intercept)"     = diag(M),
  # PO effect for tx and yprev
  "yprev"           = cbind(PO_effect = 1),
  "tx"              = cbind(PO_effect = 1),

  # linear time can have non-PO effect
  "time_lin" = cbind(
    time_lin_1 = 1,
    time_lin_5 = 0:(M-1)
  ),
  "time_nlin_1" = cbind(PO_effect = 1),
  "time_nlin_2" = cbind(PO_effect = 1)
)

cons_time_tx <- list(
  # Intercept need identity matrix
  "(Intercept)"     = diag(M),
  # PO effect for tx and yprev
  "yprev"           = cbind(PO_effect = 1),
  "tx"              = cbind(PO_effect = 1),

  # linear time can have non-PO effect
  "time_lin" = cbind(
    time_lin_1 = 1,
    time_lin_5 = 0:(M-1)
  ),
  "time_nlin_1" = cbind(PO_effect = 1),
  "time_nlin_2" = cbind(PO_effect = 1),
  # interaction terms
  "time_lin:tx" = cbind(PO_effect = 1),
  "time_nlin_1:tx" = cbind(PO_effect = 1),
  "time_nlin_2:tx" = cbind(PO_effect = 1),
  "time_lin:yprev" = cbind(PO_effect = 1)
)


# non-linear effect of time using rcs()
m1 <- vglm(ordered(y) ~ rcs(time, 4) + tx + yprev, family = cumulative(reverse = TRUE, parallel = TRUE), data = data)

# non-linear effect of time using manually created spline terms from rcs() --> this doesn't work with soprobmarkovordm from Hmisc, but is needed for partial PO of linear time of linear interactions
m2 <- vglm(ordered(y) ~ time_lin + time_nlin_1 + time_nlin_2 + tx + yprev, family = cumulative(reverse = TRUE, parallel = TRUE), data = data)

# non-linear effect of time with interaction of treatment and linear time
m3 <- vglm(ordered(y) ~ time_lin + time_nlin_1 + time_nlin_2 + tx + yprev + time_lin:tx + yprev:time_lin, family = cumulative(reverse = TRUE, parallel = TRUE), data = data)

# non-linear effect of time and non-proportional effect of linear time with linear constraint
m4 <- vglm(ordered(y) ~ time_lin + time_nlin_1 + time_nlin_2 + tx + yprev, family = cumulative(reverse = TRUE, parallel = FALSE ~ time_lin), data = data, constraints = cons_time)
# bake constraint matrix into the model object
m4@call$constraints  <- cons_time

# non-linear effect of time and non-proportional effect of linear time and interaction of treatment and linear time with linear constraint
m5 <- vglm(ordered(y) ~ (time_lin + time_nlin_1 + time_nlin_2) * tx + yprev + yprev:time_lin, family = cumulative(reverse = TRUE, parallel = FALSE ~ time_lin), data = data, constraints = cons_time_tx)
m5@call$constraints  <- cons_time_tx


# check that Hmisc and markov.misc give same results
sops_hmisc <- soprobMarkovOrdm(
  m1,
  data = data[1, ],
  time = 1:FU,
  ylevels = factor(1:6),
  absorb = "6"
)

sops_1 <- soprob_markov(
  m1,
  data = data |> filter(time == 1), #use entire data 
  time = 1:FU,
  ylevels = factor(1:6),
  absorb = "6"
)

all(sops_hmisc == sops_1[1, , ])

# check that using rcs() within model formula or manually creating splines gives same results
sops_2 <- soprob_markov(
  m2,
  data = data[1, ],
  time = 1:FU,
  ylevels = factor(1:6),
  absorb = "6",
  t_covs = t_covs
)

all(sops_2[1, , ] == sops_1[1, , ])

# testing interactions and partial po models

sops_3 <- soprob_markov(
  m3,
  data = data[1, ],
  time = 1:FU,
  ylevels = factor(1:6),
  absorb = "6",
  t_covs = t_covs
)

sops_4 <- soprob_markov(
  m4,
  data = data[1, ],
  time = 1:FU,
  ylevels = factor(1:6),
  absorb = "6",
  t_covs = t_covs
)

sops_5 <- soprob_markov(
  m5,
  data = data |> filter(time == 1),
  time = 1:FU,
  ylevels = factor(1:6),
  absorb = "6",
  t_covs = t_covs
)
```

## Step 3: Bootstrap SOPs

Full which assumed PO for everything and no interactions.

```{r}
t1 <- Sys.time()
bs_sops <- bootstrap_standardized_sops(
  model = m1,
  data = data,
  times = 1:FU,
  n_boot = R,
  ylevels = factor(1:6),
  absorb = "6",
  varnames = list(tvarname = "time", pvarname = "yprev", id = "id", tx = "tx"),
  parallel = TRUE,
  workers = 8
)
t2 <- Sys.time()
t2 - t1
```

Model which relaxes PO for linear time and adds linear time x treatment interaction.

```{r}
t1 <- Sys.time()
bs_sops_ppo <- bootstrap_standardized_sops(
  model = m5,
  data = data,
  times = 1:FU,
  n_boot = R,
  ylevels = factor(1:6),
  absorb = "6",
  varnames = list(tvarname = "time", pvarname = "yprev", id = "id", tx = "tx"),
  parallel = TRUE,
  workers = 8,
  t_covs = t_covs
)
t2 <- Sys.time()
t2 - t1
```

## Step 4: Plot Bootstrapped SOPs

```{r}
po_sops <- plot_bootstrap_sops(
  bs_sops,
  title = "PO-Model: Standardized SOPs with bootstrapped 95% confidence bands"
) +
  scale_fill_brewer(palette = "Dark2") +
  scale_color_brewer(palette = "Dark2") +
  coord_cartesian(ylim = c(0, 1.0))
```

```{r}
ppo_sops <- plot_bootstrap_sops(
  bs_sops_ppo,
  title = "Partial PO-Model + tx:time_lin: Standardized SOPs with bootstrapped 95% confidence bands"
) +
  scale_fill_brewer(palette = "Dark2") +
  scale_color_brewer(palette = "Dark2") +
  coord_cartesian(ylim = c(0, 1.0))
```

```{r}
esop + po_sops + ppo_sops +
  plot_layout(guides = "collect")
```

## Step 5: Calculate and Plot Bootstrap Distribution of Difference in Time in State 1

```{r}
time_5 <- bs_sops_ppo |> 
  time_in_state() |> 
  ggplot(aes(x = delta)) +
  ggdist::stat_dots(side = "bottom") +
  ggdist::stat_halfeye() +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Bootstrap Distribution of Difference in Time in State 1",
    x = "Difference in Time in State 1 (Treatment - Control)",
    y = ""
  )

bs_sops_ppo |> 
  time_in_state() |> 
  reframe(
    mean_tx = mean(SOP_tx),
    mean_ctrl = mean(SOP_ctrl),
  )

time_1 <- bs_sops |> 
  time_in_state() |> 
  ggplot(aes(x = delta)) +
  ggdist::stat_dots(side = "bottom") +
  ggdist::stat_halfeye() +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Bootstrap Distribution of Difference in Time in State 1",
    x = "Difference in Time in State 1 (Treatment - Control)",
    y = ""
  )

bs_sops |> 
  time_in_state() |> 
  reframe(
    mean_tx = mean(SOP_tx),
    mean_ctrl = mean(SOP_ctrl),
  )

time_1 + time_5
```


```{r}
# Clean up temporary files
unlink(DATA_PATH, recursive = TRUE)
unlink(OUTPUT_PATH, recursive = TRUE)
```